// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'model_main_vo.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$ModelVoTermsTearOff {
  const _$ModelVoTermsTearOff();

  _ModelVoTerms call(Map<ModelVoTermKey, ModelVoTermInfo> terms) {
    return _ModelVoTerms(
      terms,
    );
  }
}

/// @nodoc
const $ModelVoTerms = _$ModelVoTermsTearOff();

/// @nodoc
mixin _$ModelVoTerms {
  Map<ModelVoTermKey, ModelVoTermInfo> get terms =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoTermsCopyWith<ModelVoTerms> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoTermsCopyWith<$Res> {
  factory $ModelVoTermsCopyWith(
          ModelVoTerms value, $Res Function(ModelVoTerms) then) =
      _$ModelVoTermsCopyWithImpl<$Res>;
  $Res call({Map<ModelVoTermKey, ModelVoTermInfo> terms});
}

/// @nodoc
class _$ModelVoTermsCopyWithImpl<$Res> implements $ModelVoTermsCopyWith<$Res> {
  _$ModelVoTermsCopyWithImpl(this._value, this._then);

  final ModelVoTerms _value;
  // ignore: unused_field
  final $Res Function(ModelVoTerms) _then;

  @override
  $Res call({
    Object? terms = freezed,
  }) {
    return _then(_value.copyWith(
      terms: terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as Map<ModelVoTermKey, ModelVoTermInfo>,
    ));
  }
}

/// @nodoc
abstract class _$ModelVoTermsCopyWith<$Res>
    implements $ModelVoTermsCopyWith<$Res> {
  factory _$ModelVoTermsCopyWith(
          _ModelVoTerms value, $Res Function(_ModelVoTerms) then) =
      __$ModelVoTermsCopyWithImpl<$Res>;
  @override
  $Res call({Map<ModelVoTermKey, ModelVoTermInfo> terms});
}

/// @nodoc
class __$ModelVoTermsCopyWithImpl<$Res> extends _$ModelVoTermsCopyWithImpl<$Res>
    implements _$ModelVoTermsCopyWith<$Res> {
  __$ModelVoTermsCopyWithImpl(
      _ModelVoTerms _value, $Res Function(_ModelVoTerms) _then)
      : super(_value, (v) => _then(v as _ModelVoTerms));

  @override
  _ModelVoTerms get _value => super._value as _ModelVoTerms;

  @override
  $Res call({
    Object? terms = freezed,
  }) {
    return _then(_ModelVoTerms(
      terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as Map<ModelVoTermKey, ModelVoTermInfo>,
    ));
  }
}

/// @nodoc

class _$_ModelVoTerms with DiagnosticableTreeMixin implements _ModelVoTerms {
  const _$_ModelVoTerms(this.terms);

  @override
  final Map<ModelVoTermKey, ModelVoTermInfo> terms;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoTerms(terms: $terms)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoTerms'))
      ..add(DiagnosticsProperty('terms', terms));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoTerms &&
            (identical(other.terms, terms) ||
                const DeepCollectionEquality().equals(other.terms, terms)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(terms);

  @JsonKey(ignore: true)
  @override
  _$ModelVoTermsCopyWith<_ModelVoTerms> get copyWith =>
      __$ModelVoTermsCopyWithImpl<_ModelVoTerms>(this, _$identity);
}

abstract class _ModelVoTerms implements ModelVoTerms {
  const factory _ModelVoTerms(Map<ModelVoTermKey, ModelVoTermInfo> terms) =
      _$_ModelVoTerms;

  @override
  Map<ModelVoTermKey, ModelVoTermInfo> get terms =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoTermsCopyWith<_ModelVoTerms> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModelVoTermKeyTearOff {
  const _$ModelVoTermKeyTearOff();

  _ModelVoTermKey call(int id) {
    return _ModelVoTermKey(
      id,
    );
  }
}

/// @nodoc
const $ModelVoTermKey = _$ModelVoTermKeyTearOff();

/// @nodoc
mixin _$ModelVoTermKey {
  int get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoTermKeyCopyWith<ModelVoTermKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoTermKeyCopyWith<$Res> {
  factory $ModelVoTermKeyCopyWith(
          ModelVoTermKey value, $Res Function(ModelVoTermKey) then) =
      _$ModelVoTermKeyCopyWithImpl<$Res>;
  $Res call({int id});
}

/// @nodoc
class _$ModelVoTermKeyCopyWithImpl<$Res>
    implements $ModelVoTermKeyCopyWith<$Res> {
  _$ModelVoTermKeyCopyWithImpl(this._value, this._then);

  final ModelVoTermKey _value;
  // ignore: unused_field
  final $Res Function(ModelVoTermKey) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$ModelVoTermKeyCopyWith<$Res>
    implements $ModelVoTermKeyCopyWith<$Res> {
  factory _$ModelVoTermKeyCopyWith(
          _ModelVoTermKey value, $Res Function(_ModelVoTermKey) then) =
      __$ModelVoTermKeyCopyWithImpl<$Res>;
  @override
  $Res call({int id});
}

/// @nodoc
class __$ModelVoTermKeyCopyWithImpl<$Res>
    extends _$ModelVoTermKeyCopyWithImpl<$Res>
    implements _$ModelVoTermKeyCopyWith<$Res> {
  __$ModelVoTermKeyCopyWithImpl(
      _ModelVoTermKey _value, $Res Function(_ModelVoTermKey) _then)
      : super(_value, (v) => _then(v as _ModelVoTermKey));

  @override
  _ModelVoTermKey get _value => super._value as _ModelVoTermKey;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_ModelVoTermKey(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_ModelVoTermKey
    with DiagnosticableTreeMixin
    implements _ModelVoTermKey {
  const _$_ModelVoTermKey(this.id);

  @override
  final int id;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoTermKey(id: $id)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoTermKey'))
      ..add(DiagnosticsProperty('id', id));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoTermKey &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(id);

  @JsonKey(ignore: true)
  @override
  _$ModelVoTermKeyCopyWith<_ModelVoTermKey> get copyWith =>
      __$ModelVoTermKeyCopyWithImpl<_ModelVoTermKey>(this, _$identity);
}

abstract class _ModelVoTermKey implements ModelVoTermKey {
  const factory _ModelVoTermKey(int id) = _$_ModelVoTermKey;

  @override
  int get id => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoTermKeyCopyWith<_ModelVoTermKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModelVoTermInfoTearOff {
  const _$ModelVoTermInfoTearOff();

  _ModelVoTermInfo call(String name, List<WeekDay> weekDays, int maxPeriod) {
    return _ModelVoTermInfo(
      name,
      weekDays,
      maxPeriod,
    );
  }
}

/// @nodoc
const $ModelVoTermInfo = _$ModelVoTermInfoTearOff();

/// @nodoc
mixin _$ModelVoTermInfo {
  String get name => throw _privateConstructorUsedError;
  List<WeekDay> get weekDays => throw _privateConstructorUsedError;
  int get maxPeriod => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoTermInfoCopyWith<ModelVoTermInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoTermInfoCopyWith<$Res> {
  factory $ModelVoTermInfoCopyWith(
          ModelVoTermInfo value, $Res Function(ModelVoTermInfo) then) =
      _$ModelVoTermInfoCopyWithImpl<$Res>;
  $Res call({String name, List<WeekDay> weekDays, int maxPeriod});
}

/// @nodoc
class _$ModelVoTermInfoCopyWithImpl<$Res>
    implements $ModelVoTermInfoCopyWith<$Res> {
  _$ModelVoTermInfoCopyWithImpl(this._value, this._then);

  final ModelVoTermInfo _value;
  // ignore: unused_field
  final $Res Function(ModelVoTermInfo) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? weekDays = freezed,
    Object? maxPeriod = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      weekDays: weekDays == freezed
          ? _value.weekDays
          : weekDays // ignore: cast_nullable_to_non_nullable
              as List<WeekDay>,
      maxPeriod: maxPeriod == freezed
          ? _value.maxPeriod
          : maxPeriod // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$ModelVoTermInfoCopyWith<$Res>
    implements $ModelVoTermInfoCopyWith<$Res> {
  factory _$ModelVoTermInfoCopyWith(
          _ModelVoTermInfo value, $Res Function(_ModelVoTermInfo) then) =
      __$ModelVoTermInfoCopyWithImpl<$Res>;
  @override
  $Res call({String name, List<WeekDay> weekDays, int maxPeriod});
}

/// @nodoc
class __$ModelVoTermInfoCopyWithImpl<$Res>
    extends _$ModelVoTermInfoCopyWithImpl<$Res>
    implements _$ModelVoTermInfoCopyWith<$Res> {
  __$ModelVoTermInfoCopyWithImpl(
      _ModelVoTermInfo _value, $Res Function(_ModelVoTermInfo) _then)
      : super(_value, (v) => _then(v as _ModelVoTermInfo));

  @override
  _ModelVoTermInfo get _value => super._value as _ModelVoTermInfo;

  @override
  $Res call({
    Object? name = freezed,
    Object? weekDays = freezed,
    Object? maxPeriod = freezed,
  }) {
    return _then(_ModelVoTermInfo(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      weekDays == freezed
          ? _value.weekDays
          : weekDays // ignore: cast_nullable_to_non_nullable
              as List<WeekDay>,
      maxPeriod == freezed
          ? _value.maxPeriod
          : maxPeriod // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_ModelVoTermInfo
    with DiagnosticableTreeMixin
    implements _ModelVoTermInfo {
  const _$_ModelVoTermInfo(this.name, this.weekDays, this.maxPeriod);

  @override
  final String name;
  @override
  final List<WeekDay> weekDays;
  @override
  final int maxPeriod;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoTermInfo(name: $name, weekDays: $weekDays, maxPeriod: $maxPeriod)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoTermInfo'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('weekDays', weekDays))
      ..add(DiagnosticsProperty('maxPeriod', maxPeriod));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoTermInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.weekDays, weekDays) ||
                const DeepCollectionEquality()
                    .equals(other.weekDays, weekDays)) &&
            (identical(other.maxPeriod, maxPeriod) ||
                const DeepCollectionEquality()
                    .equals(other.maxPeriod, maxPeriod)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(weekDays) ^
      const DeepCollectionEquality().hash(maxPeriod);

  @JsonKey(ignore: true)
  @override
  _$ModelVoTermInfoCopyWith<_ModelVoTermInfo> get copyWith =>
      __$ModelVoTermInfoCopyWithImpl<_ModelVoTermInfo>(this, _$identity);
}

abstract class _ModelVoTermInfo implements ModelVoTermInfo {
  const factory _ModelVoTermInfo(
      String name, List<WeekDay> weekDays, int maxPeriod) = _$_ModelVoTermInfo;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  List<WeekDay> get weekDays => throw _privateConstructorUsedError;
  @override
  int get maxPeriod => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoTermInfoCopyWith<_ModelVoTermInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModelVoClassesTearOff {
  const _$ModelVoClassesTearOff();

  _ModelVoClasses call(Map<ModelVoClassKey, ModelVoClassInfo> classes) {
    return _ModelVoClasses(
      classes,
    );
  }
}

/// @nodoc
const $ModelVoClasses = _$ModelVoClassesTearOff();

/// @nodoc
mixin _$ModelVoClasses {
  Map<ModelVoClassKey, ModelVoClassInfo> get classes =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoClassesCopyWith<ModelVoClasses> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoClassesCopyWith<$Res> {
  factory $ModelVoClassesCopyWith(
          ModelVoClasses value, $Res Function(ModelVoClasses) then) =
      _$ModelVoClassesCopyWithImpl<$Res>;
  $Res call({Map<ModelVoClassKey, ModelVoClassInfo> classes});
}

/// @nodoc
class _$ModelVoClassesCopyWithImpl<$Res>
    implements $ModelVoClassesCopyWith<$Res> {
  _$ModelVoClassesCopyWithImpl(this._value, this._then);

  final ModelVoClasses _value;
  // ignore: unused_field
  final $Res Function(ModelVoClasses) _then;

  @override
  $Res call({
    Object? classes = freezed,
  }) {
    return _then(_value.copyWith(
      classes: classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as Map<ModelVoClassKey, ModelVoClassInfo>,
    ));
  }
}

/// @nodoc
abstract class _$ModelVoClassesCopyWith<$Res>
    implements $ModelVoClassesCopyWith<$Res> {
  factory _$ModelVoClassesCopyWith(
          _ModelVoClasses value, $Res Function(_ModelVoClasses) then) =
      __$ModelVoClassesCopyWithImpl<$Res>;
  @override
  $Res call({Map<ModelVoClassKey, ModelVoClassInfo> classes});
}

/// @nodoc
class __$ModelVoClassesCopyWithImpl<$Res>
    extends _$ModelVoClassesCopyWithImpl<$Res>
    implements _$ModelVoClassesCopyWith<$Res> {
  __$ModelVoClassesCopyWithImpl(
      _ModelVoClasses _value, $Res Function(_ModelVoClasses) _then)
      : super(_value, (v) => _then(v as _ModelVoClasses));

  @override
  _ModelVoClasses get _value => super._value as _ModelVoClasses;

  @override
  $Res call({
    Object? classes = freezed,
  }) {
    return _then(_ModelVoClasses(
      classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as Map<ModelVoClassKey, ModelVoClassInfo>,
    ));
  }
}

/// @nodoc

class _$_ModelVoClasses
    with DiagnosticableTreeMixin
    implements _ModelVoClasses {
  const _$_ModelVoClasses(this.classes);

  @override
  final Map<ModelVoClassKey, ModelVoClassInfo> classes;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoClasses(classes: $classes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoClasses'))
      ..add(DiagnosticsProperty('classes', classes));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoClasses &&
            (identical(other.classes, classes) ||
                const DeepCollectionEquality().equals(other.classes, classes)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(classes);

  @JsonKey(ignore: true)
  @override
  _$ModelVoClassesCopyWith<_ModelVoClasses> get copyWith =>
      __$ModelVoClassesCopyWithImpl<_ModelVoClasses>(this, _$identity);
}

abstract class _ModelVoClasses implements ModelVoClasses {
  const factory _ModelVoClasses(
      Map<ModelVoClassKey, ModelVoClassInfo> classes) = _$_ModelVoClasses;

  @override
  Map<ModelVoClassKey, ModelVoClassInfo> get classes =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoClassesCopyWith<_ModelVoClasses> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModelVoClassKeyTearOff {
  const _$ModelVoClassKeyTearOff();

  _ModelVoClassKey call(WeekDay weekDay, int period) {
    return _ModelVoClassKey(
      weekDay,
      period,
    );
  }
}

/// @nodoc
const $ModelVoClassKey = _$ModelVoClassKeyTearOff();

/// @nodoc
mixin _$ModelVoClassKey {
  WeekDay get weekDay => throw _privateConstructorUsedError;
  int get period => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoClassKeyCopyWith<ModelVoClassKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoClassKeyCopyWith<$Res> {
  factory $ModelVoClassKeyCopyWith(
          ModelVoClassKey value, $Res Function(ModelVoClassKey) then) =
      _$ModelVoClassKeyCopyWithImpl<$Res>;
  $Res call({WeekDay weekDay, int period});
}

/// @nodoc
class _$ModelVoClassKeyCopyWithImpl<$Res>
    implements $ModelVoClassKeyCopyWith<$Res> {
  _$ModelVoClassKeyCopyWithImpl(this._value, this._then);

  final ModelVoClassKey _value;
  // ignore: unused_field
  final $Res Function(ModelVoClassKey) _then;

  @override
  $Res call({
    Object? weekDay = freezed,
    Object? period = freezed,
  }) {
    return _then(_value.copyWith(
      weekDay: weekDay == freezed
          ? _value.weekDay
          : weekDay // ignore: cast_nullable_to_non_nullable
              as WeekDay,
      period: period == freezed
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$ModelVoClassKeyCopyWith<$Res>
    implements $ModelVoClassKeyCopyWith<$Res> {
  factory _$ModelVoClassKeyCopyWith(
          _ModelVoClassKey value, $Res Function(_ModelVoClassKey) then) =
      __$ModelVoClassKeyCopyWithImpl<$Res>;
  @override
  $Res call({WeekDay weekDay, int period});
}

/// @nodoc
class __$ModelVoClassKeyCopyWithImpl<$Res>
    extends _$ModelVoClassKeyCopyWithImpl<$Res>
    implements _$ModelVoClassKeyCopyWith<$Res> {
  __$ModelVoClassKeyCopyWithImpl(
      _ModelVoClassKey _value, $Res Function(_ModelVoClassKey) _then)
      : super(_value, (v) => _then(v as _ModelVoClassKey));

  @override
  _ModelVoClassKey get _value => super._value as _ModelVoClassKey;

  @override
  $Res call({
    Object? weekDay = freezed,
    Object? period = freezed,
  }) {
    return _then(_ModelVoClassKey(
      weekDay == freezed
          ? _value.weekDay
          : weekDay // ignore: cast_nullable_to_non_nullable
              as WeekDay,
      period == freezed
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_ModelVoClassKey
    with DiagnosticableTreeMixin
    implements _ModelVoClassKey {
  const _$_ModelVoClassKey(this.weekDay, this.period);

  @override
  final WeekDay weekDay;
  @override
  final int period;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoClassKey(weekDay: $weekDay, period: $period)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoClassKey'))
      ..add(DiagnosticsProperty('weekDay', weekDay))
      ..add(DiagnosticsProperty('period', period));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoClassKey &&
            (identical(other.weekDay, weekDay) ||
                const DeepCollectionEquality()
                    .equals(other.weekDay, weekDay)) &&
            (identical(other.period, period) ||
                const DeepCollectionEquality().equals(other.period, period)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(weekDay) ^
      const DeepCollectionEquality().hash(period);

  @JsonKey(ignore: true)
  @override
  _$ModelVoClassKeyCopyWith<_ModelVoClassKey> get copyWith =>
      __$ModelVoClassKeyCopyWithImpl<_ModelVoClassKey>(this, _$identity);
}

abstract class _ModelVoClassKey implements ModelVoClassKey {
  const factory _ModelVoClassKey(WeekDay weekDay, int period) =
      _$_ModelVoClassKey;

  @override
  WeekDay get weekDay => throw _privateConstructorUsedError;
  @override
  int get period => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoClassKeyCopyWith<_ModelVoClassKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModelVoClassInfoTearOff {
  const _$ModelVoClassInfoTearOff();

  _ModelVoClassInfo call(String name, String room) {
    return _ModelVoClassInfo(
      name,
      room,
    );
  }
}

/// @nodoc
const $ModelVoClassInfo = _$ModelVoClassInfoTearOff();

/// @nodoc
mixin _$ModelVoClassInfo {
  String get name => throw _privateConstructorUsedError;
  String get room => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoClassInfoCopyWith<ModelVoClassInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoClassInfoCopyWith<$Res> {
  factory $ModelVoClassInfoCopyWith(
          ModelVoClassInfo value, $Res Function(ModelVoClassInfo) then) =
      _$ModelVoClassInfoCopyWithImpl<$Res>;
  $Res call({String name, String room});
}

/// @nodoc
class _$ModelVoClassInfoCopyWithImpl<$Res>
    implements $ModelVoClassInfoCopyWith<$Res> {
  _$ModelVoClassInfoCopyWithImpl(this._value, this._then);

  final ModelVoClassInfo _value;
  // ignore: unused_field
  final $Res Function(ModelVoClassInfo) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? room = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      room: room == freezed
          ? _value.room
          : room // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$ModelVoClassInfoCopyWith<$Res>
    implements $ModelVoClassInfoCopyWith<$Res> {
  factory _$ModelVoClassInfoCopyWith(
          _ModelVoClassInfo value, $Res Function(_ModelVoClassInfo) then) =
      __$ModelVoClassInfoCopyWithImpl<$Res>;
  @override
  $Res call({String name, String room});
}

/// @nodoc
class __$ModelVoClassInfoCopyWithImpl<$Res>
    extends _$ModelVoClassInfoCopyWithImpl<$Res>
    implements _$ModelVoClassInfoCopyWith<$Res> {
  __$ModelVoClassInfoCopyWithImpl(
      _ModelVoClassInfo _value, $Res Function(_ModelVoClassInfo) _then)
      : super(_value, (v) => _then(v as _ModelVoClassInfo));

  @override
  _ModelVoClassInfo get _value => super._value as _ModelVoClassInfo;

  @override
  $Res call({
    Object? name = freezed,
    Object? room = freezed,
  }) {
    return _then(_ModelVoClassInfo(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      room == freezed
          ? _value.room
          : room // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_ModelVoClassInfo
    with DiagnosticableTreeMixin
    implements _ModelVoClassInfo {
  const _$_ModelVoClassInfo(this.name, this.room);

  @override
  final String name;
  @override
  final String room;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoClassInfo(name: $name, room: $room)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoClassInfo'))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('room', room));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoClassInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.room, room) ||
                const DeepCollectionEquality().equals(other.room, room)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(room);

  @JsonKey(ignore: true)
  @override
  _$ModelVoClassInfoCopyWith<_ModelVoClassInfo> get copyWith =>
      __$ModelVoClassInfoCopyWithImpl<_ModelVoClassInfo>(this, _$identity);
}

abstract class _ModelVoClassInfo implements ModelVoClassInfo {
  const factory _ModelVoClassInfo(String name, String room) =
      _$_ModelVoClassInfo;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  String get room => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoClassInfoCopyWith<_ModelVoClassInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ModelVoTermAndClassesTearOff {
  const _$ModelVoTermAndClassesTearOff();

  _ModelVoTermAndClasses call(ModelVoTermInfo termInfo,
      Map<ModelVoClassKey, ModelVoClassInfo> classes) {
    return _ModelVoTermAndClasses(
      termInfo,
      classes,
    );
  }
}

/// @nodoc
const $ModelVoTermAndClasses = _$ModelVoTermAndClassesTearOff();

/// @nodoc
mixin _$ModelVoTermAndClasses {
  ModelVoTermInfo get termInfo => throw _privateConstructorUsedError;
  Map<ModelVoClassKey, ModelVoClassInfo> get classes =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ModelVoTermAndClassesCopyWith<ModelVoTermAndClasses> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ModelVoTermAndClassesCopyWith<$Res> {
  factory $ModelVoTermAndClassesCopyWith(ModelVoTermAndClasses value,
          $Res Function(ModelVoTermAndClasses) then) =
      _$ModelVoTermAndClassesCopyWithImpl<$Res>;
  $Res call(
      {ModelVoTermInfo termInfo,
      Map<ModelVoClassKey, ModelVoClassInfo> classes});

  $ModelVoTermInfoCopyWith<$Res> get termInfo;
}

/// @nodoc
class _$ModelVoTermAndClassesCopyWithImpl<$Res>
    implements $ModelVoTermAndClassesCopyWith<$Res> {
  _$ModelVoTermAndClassesCopyWithImpl(this._value, this._then);

  final ModelVoTermAndClasses _value;
  // ignore: unused_field
  final $Res Function(ModelVoTermAndClasses) _then;

  @override
  $Res call({
    Object? termInfo = freezed,
    Object? classes = freezed,
  }) {
    return _then(_value.copyWith(
      termInfo: termInfo == freezed
          ? _value.termInfo
          : termInfo // ignore: cast_nullable_to_non_nullable
              as ModelVoTermInfo,
      classes: classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as Map<ModelVoClassKey, ModelVoClassInfo>,
    ));
  }

  @override
  $ModelVoTermInfoCopyWith<$Res> get termInfo {
    return $ModelVoTermInfoCopyWith<$Res>(_value.termInfo, (value) {
      return _then(_value.copyWith(termInfo: value));
    });
  }
}

/// @nodoc
abstract class _$ModelVoTermAndClassesCopyWith<$Res>
    implements $ModelVoTermAndClassesCopyWith<$Res> {
  factory _$ModelVoTermAndClassesCopyWith(_ModelVoTermAndClasses value,
          $Res Function(_ModelVoTermAndClasses) then) =
      __$ModelVoTermAndClassesCopyWithImpl<$Res>;
  @override
  $Res call(
      {ModelVoTermInfo termInfo,
      Map<ModelVoClassKey, ModelVoClassInfo> classes});

  @override
  $ModelVoTermInfoCopyWith<$Res> get termInfo;
}

/// @nodoc
class __$ModelVoTermAndClassesCopyWithImpl<$Res>
    extends _$ModelVoTermAndClassesCopyWithImpl<$Res>
    implements _$ModelVoTermAndClassesCopyWith<$Res> {
  __$ModelVoTermAndClassesCopyWithImpl(_ModelVoTermAndClasses _value,
      $Res Function(_ModelVoTermAndClasses) _then)
      : super(_value, (v) => _then(v as _ModelVoTermAndClasses));

  @override
  _ModelVoTermAndClasses get _value => super._value as _ModelVoTermAndClasses;

  @override
  $Res call({
    Object? termInfo = freezed,
    Object? classes = freezed,
  }) {
    return _then(_ModelVoTermAndClasses(
      termInfo == freezed
          ? _value.termInfo
          : termInfo // ignore: cast_nullable_to_non_nullable
              as ModelVoTermInfo,
      classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as Map<ModelVoClassKey, ModelVoClassInfo>,
    ));
  }
}

/// @nodoc

class _$_ModelVoTermAndClasses
    with DiagnosticableTreeMixin
    implements _ModelVoTermAndClasses {
  const _$_ModelVoTermAndClasses(this.termInfo, this.classes);

  @override
  final ModelVoTermInfo termInfo;
  @override
  final Map<ModelVoClassKey, ModelVoClassInfo> classes;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ModelVoTermAndClasses(termInfo: $termInfo, classes: $classes)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ModelVoTermAndClasses'))
      ..add(DiagnosticsProperty('termInfo', termInfo))
      ..add(DiagnosticsProperty('classes', classes));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ModelVoTermAndClasses &&
            (identical(other.termInfo, termInfo) ||
                const DeepCollectionEquality()
                    .equals(other.termInfo, termInfo)) &&
            (identical(other.classes, classes) ||
                const DeepCollectionEquality().equals(other.classes, classes)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(termInfo) ^
      const DeepCollectionEquality().hash(classes);

  @JsonKey(ignore: true)
  @override
  _$ModelVoTermAndClassesCopyWith<_ModelVoTermAndClasses> get copyWith =>
      __$ModelVoTermAndClassesCopyWithImpl<_ModelVoTermAndClasses>(
          this, _$identity);
}

abstract class _ModelVoTermAndClasses implements ModelVoTermAndClasses {
  const factory _ModelVoTermAndClasses(ModelVoTermInfo termInfo,
          Map<ModelVoClassKey, ModelVoClassInfo> classes) =
      _$_ModelVoTermAndClasses;

  @override
  ModelVoTermInfo get termInfo => throw _privateConstructorUsedError;
  @override
  Map<ModelVoClassKey, ModelVoClassInfo> get classes =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$ModelVoTermAndClassesCopyWith<_ModelVoTermAndClasses> get copyWith =>
      throw _privateConstructorUsedError;
}
