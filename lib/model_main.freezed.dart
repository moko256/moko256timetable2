// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'model_main.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$EntityMainClassInfoTearOff {
  const _$EntityMainClassInfoTearOff();

  _EntityMainClassInfo call(String name, String room) {
    return _EntityMainClassInfo(
      name,
      room,
    );
  }
}

/// @nodoc
const $EntityMainClassInfo = _$EntityMainClassInfoTearOff();

/// @nodoc
mixin _$EntityMainClassInfo {
  String get name => throw _privateConstructorUsedError;
  String get room => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainClassInfoCopyWith<EntityMainClassInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainClassInfoCopyWith<$Res> {
  factory $EntityMainClassInfoCopyWith(
          EntityMainClassInfo value, $Res Function(EntityMainClassInfo) then) =
      _$EntityMainClassInfoCopyWithImpl<$Res>;
  $Res call({String name, String room});
}

/// @nodoc
class _$EntityMainClassInfoCopyWithImpl<$Res>
    implements $EntityMainClassInfoCopyWith<$Res> {
  _$EntityMainClassInfoCopyWithImpl(this._value, this._then);

  final EntityMainClassInfo _value;
  // ignore: unused_field
  final $Res Function(EntityMainClassInfo) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? room = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      room: room == freezed
          ? _value.room
          : room // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
abstract class _$EntityMainClassInfoCopyWith<$Res>
    implements $EntityMainClassInfoCopyWith<$Res> {
  factory _$EntityMainClassInfoCopyWith(_EntityMainClassInfo value,
          $Res Function(_EntityMainClassInfo) then) =
      __$EntityMainClassInfoCopyWithImpl<$Res>;
  @override
  $Res call({String name, String room});
}

/// @nodoc
class __$EntityMainClassInfoCopyWithImpl<$Res>
    extends _$EntityMainClassInfoCopyWithImpl<$Res>
    implements _$EntityMainClassInfoCopyWith<$Res> {
  __$EntityMainClassInfoCopyWithImpl(
      _EntityMainClassInfo _value, $Res Function(_EntityMainClassInfo) _then)
      : super(_value, (v) => _then(v as _EntityMainClassInfo));

  @override
  _EntityMainClassInfo get _value => super._value as _EntityMainClassInfo;

  @override
  $Res call({
    Object? name = freezed,
    Object? room = freezed,
  }) {
    return _then(_EntityMainClassInfo(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      room == freezed
          ? _value.room
          : room // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_EntityMainClassInfo implements _EntityMainClassInfo {
  _$_EntityMainClassInfo(this.name, this.room);

  @override
  final String name;
  @override
  final String room;

  @override
  String toString() {
    return 'EntityMainClassInfo(name: $name, room: $room)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainClassInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.room, room) ||
                const DeepCollectionEquality().equals(other.room, room)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(room);

  @JsonKey(ignore: true)
  @override
  _$EntityMainClassInfoCopyWith<_EntityMainClassInfo> get copyWith =>
      __$EntityMainClassInfoCopyWithImpl<_EntityMainClassInfo>(
          this, _$identity);
}

abstract class _EntityMainClassInfo implements EntityMainClassInfo {
  factory _EntityMainClassInfo(String name, String room) =
      _$_EntityMainClassInfo;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  String get room => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainClassInfoCopyWith<_EntityMainClassInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainClassWhereTearOff {
  const _$EntityMainClassWhereTearOff();

  _EntityMainClassWhere call(WeekDay weekDay, Duration period) {
    return _EntityMainClassWhere(
      weekDay,
      period,
    );
  }
}

/// @nodoc
const $EntityMainClassWhere = _$EntityMainClassWhereTearOff();

/// @nodoc
mixin _$EntityMainClassWhere {
  WeekDay get weekDay => throw _privateConstructorUsedError;
  Duration get period => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainClassWhereCopyWith<EntityMainClassWhere> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainClassWhereCopyWith<$Res> {
  factory $EntityMainClassWhereCopyWith(EntityMainClassWhere value,
          $Res Function(EntityMainClassWhere) then) =
      _$EntityMainClassWhereCopyWithImpl<$Res>;
  $Res call({WeekDay weekDay, Duration period});
}

/// @nodoc
class _$EntityMainClassWhereCopyWithImpl<$Res>
    implements $EntityMainClassWhereCopyWith<$Res> {
  _$EntityMainClassWhereCopyWithImpl(this._value, this._then);

  final EntityMainClassWhere _value;
  // ignore: unused_field
  final $Res Function(EntityMainClassWhere) _then;

  @override
  $Res call({
    Object? weekDay = freezed,
    Object? period = freezed,
  }) {
    return _then(_value.copyWith(
      weekDay: weekDay == freezed
          ? _value.weekDay
          : weekDay // ignore: cast_nullable_to_non_nullable
              as WeekDay,
      period: period == freezed
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }
}

/// @nodoc
abstract class _$EntityMainClassWhereCopyWith<$Res>
    implements $EntityMainClassWhereCopyWith<$Res> {
  factory _$EntityMainClassWhereCopyWith(_EntityMainClassWhere value,
          $Res Function(_EntityMainClassWhere) then) =
      __$EntityMainClassWhereCopyWithImpl<$Res>;
  @override
  $Res call({WeekDay weekDay, Duration period});
}

/// @nodoc
class __$EntityMainClassWhereCopyWithImpl<$Res>
    extends _$EntityMainClassWhereCopyWithImpl<$Res>
    implements _$EntityMainClassWhereCopyWith<$Res> {
  __$EntityMainClassWhereCopyWithImpl(
      _EntityMainClassWhere _value, $Res Function(_EntityMainClassWhere) _then)
      : super(_value, (v) => _then(v as _EntityMainClassWhere));

  @override
  _EntityMainClassWhere get _value => super._value as _EntityMainClassWhere;

  @override
  $Res call({
    Object? weekDay = freezed,
    Object? period = freezed,
  }) {
    return _then(_EntityMainClassWhere(
      weekDay == freezed
          ? _value.weekDay
          : weekDay // ignore: cast_nullable_to_non_nullable
              as WeekDay,
      period == freezed
          ? _value.period
          : period // ignore: cast_nullable_to_non_nullable
              as Duration,
    ));
  }
}

/// @nodoc

class _$_EntityMainClassWhere implements _EntityMainClassWhere {
  _$_EntityMainClassWhere(this.weekDay, this.period);

  @override
  final WeekDay weekDay;
  @override
  final Duration period;

  @override
  String toString() {
    return 'EntityMainClassWhere(weekDay: $weekDay, period: $period)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainClassWhere &&
            (identical(other.weekDay, weekDay) ||
                const DeepCollectionEquality()
                    .equals(other.weekDay, weekDay)) &&
            (identical(other.period, period) ||
                const DeepCollectionEquality().equals(other.period, period)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(weekDay) ^
      const DeepCollectionEquality().hash(period);

  @JsonKey(ignore: true)
  @override
  _$EntityMainClassWhereCopyWith<_EntityMainClassWhere> get copyWith =>
      __$EntityMainClassWhereCopyWithImpl<_EntityMainClassWhere>(
          this, _$identity);
}

abstract class _EntityMainClassWhere implements EntityMainClassWhere {
  factory _EntityMainClassWhere(WeekDay weekDay, Duration period) =
      _$_EntityMainClassWhere;

  @override
  WeekDay get weekDay => throw _privateConstructorUsedError;
  @override
  Duration get period => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainClassWhereCopyWith<_EntityMainClassWhere> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainClassEditingTearOff {
  const _$EntityMainClassEditingTearOff();

  _EntityMainClassEditing call(
      EntityMainClassWhere where, EntityMainClassInfo? initialInfo) {
    return _EntityMainClassEditing(
      where,
      initialInfo,
    );
  }
}

/// @nodoc
const $EntityMainClassEditing = _$EntityMainClassEditingTearOff();

/// @nodoc
mixin _$EntityMainClassEditing {
  EntityMainClassWhere get where => throw _privateConstructorUsedError;
  EntityMainClassInfo? get initialInfo => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainClassEditingCopyWith<EntityMainClassEditing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainClassEditingCopyWith<$Res> {
  factory $EntityMainClassEditingCopyWith(EntityMainClassEditing value,
          $Res Function(EntityMainClassEditing) then) =
      _$EntityMainClassEditingCopyWithImpl<$Res>;
  $Res call({EntityMainClassWhere where, EntityMainClassInfo? initialInfo});

  $EntityMainClassWhereCopyWith<$Res> get where;
  $EntityMainClassInfoCopyWith<$Res>? get initialInfo;
}

/// @nodoc
class _$EntityMainClassEditingCopyWithImpl<$Res>
    implements $EntityMainClassEditingCopyWith<$Res> {
  _$EntityMainClassEditingCopyWithImpl(this._value, this._then);

  final EntityMainClassEditing _value;
  // ignore: unused_field
  final $Res Function(EntityMainClassEditing) _then;

  @override
  $Res call({
    Object? where = freezed,
    Object? initialInfo = freezed,
  }) {
    return _then(_value.copyWith(
      where: where == freezed
          ? _value.where
          : where // ignore: cast_nullable_to_non_nullable
              as EntityMainClassWhere,
      initialInfo: initialInfo == freezed
          ? _value.initialInfo
          : initialInfo // ignore: cast_nullable_to_non_nullable
              as EntityMainClassInfo?,
    ));
  }

  @override
  $EntityMainClassWhereCopyWith<$Res> get where {
    return $EntityMainClassWhereCopyWith<$Res>(_value.where, (value) {
      return _then(_value.copyWith(where: value));
    });
  }

  @override
  $EntityMainClassInfoCopyWith<$Res>? get initialInfo {
    if (_value.initialInfo == null) {
      return null;
    }

    return $EntityMainClassInfoCopyWith<$Res>(_value.initialInfo!, (value) {
      return _then(_value.copyWith(initialInfo: value));
    });
  }
}

/// @nodoc
abstract class _$EntityMainClassEditingCopyWith<$Res>
    implements $EntityMainClassEditingCopyWith<$Res> {
  factory _$EntityMainClassEditingCopyWith(_EntityMainClassEditing value,
          $Res Function(_EntityMainClassEditing) then) =
      __$EntityMainClassEditingCopyWithImpl<$Res>;
  @override
  $Res call({EntityMainClassWhere where, EntityMainClassInfo? initialInfo});

  @override
  $EntityMainClassWhereCopyWith<$Res> get where;
  @override
  $EntityMainClassInfoCopyWith<$Res>? get initialInfo;
}

/// @nodoc
class __$EntityMainClassEditingCopyWithImpl<$Res>
    extends _$EntityMainClassEditingCopyWithImpl<$Res>
    implements _$EntityMainClassEditingCopyWith<$Res> {
  __$EntityMainClassEditingCopyWithImpl(_EntityMainClassEditing _value,
      $Res Function(_EntityMainClassEditing) _then)
      : super(_value, (v) => _then(v as _EntityMainClassEditing));

  @override
  _EntityMainClassEditing get _value => super._value as _EntityMainClassEditing;

  @override
  $Res call({
    Object? where = freezed,
    Object? initialInfo = freezed,
  }) {
    return _then(_EntityMainClassEditing(
      where == freezed
          ? _value.where
          : where // ignore: cast_nullable_to_non_nullable
              as EntityMainClassWhere,
      initialInfo == freezed
          ? _value.initialInfo
          : initialInfo // ignore: cast_nullable_to_non_nullable
              as EntityMainClassInfo?,
    ));
  }
}

/// @nodoc

class _$_EntityMainClassEditing implements _EntityMainClassEditing {
  _$_EntityMainClassEditing(this.where, this.initialInfo);

  @override
  final EntityMainClassWhere where;
  @override
  final EntityMainClassInfo? initialInfo;

  @override
  String toString() {
    return 'EntityMainClassEditing(where: $where, initialInfo: $initialInfo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainClassEditing &&
            (identical(other.where, where) ||
                const DeepCollectionEquality().equals(other.where, where)) &&
            (identical(other.initialInfo, initialInfo) ||
                const DeepCollectionEquality()
                    .equals(other.initialInfo, initialInfo)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(where) ^
      const DeepCollectionEquality().hash(initialInfo);

  @JsonKey(ignore: true)
  @override
  _$EntityMainClassEditingCopyWith<_EntityMainClassEditing> get copyWith =>
      __$EntityMainClassEditingCopyWithImpl<_EntityMainClassEditing>(
          this, _$identity);
}

abstract class _EntityMainClassEditing implements EntityMainClassEditing {
  factory _EntityMainClassEditing(
          EntityMainClassWhere where, EntityMainClassInfo? initialInfo) =
      _$_EntityMainClassEditing;

  @override
  EntityMainClassWhere get where => throw _privateConstructorUsedError;
  @override
  EntityMainClassInfo? get initialInfo => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainClassEditingCopyWith<_EntityMainClassEditing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainClassesMapTearOff {
  const _$EntityMainClassesMapTearOff();

  _EntityMainClassesMap call(
      Map<EntityMainClassWhere, EntityMainClassInfo> map) {
    return _EntityMainClassesMap(
      map,
    );
  }
}

/// @nodoc
const $EntityMainClassesMap = _$EntityMainClassesMapTearOff();

/// @nodoc
mixin _$EntityMainClassesMap {
  Map<EntityMainClassWhere, EntityMainClassInfo> get map =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainClassesMapCopyWith<EntityMainClassesMap> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainClassesMapCopyWith<$Res> {
  factory $EntityMainClassesMapCopyWith(EntityMainClassesMap value,
          $Res Function(EntityMainClassesMap) then) =
      _$EntityMainClassesMapCopyWithImpl<$Res>;
  $Res call({Map<EntityMainClassWhere, EntityMainClassInfo> map});
}

/// @nodoc
class _$EntityMainClassesMapCopyWithImpl<$Res>
    implements $EntityMainClassesMapCopyWith<$Res> {
  _$EntityMainClassesMapCopyWithImpl(this._value, this._then);

  final EntityMainClassesMap _value;
  // ignore: unused_field
  final $Res Function(EntityMainClassesMap) _then;

  @override
  $Res call({
    Object? map = freezed,
  }) {
    return _then(_value.copyWith(
      map: map == freezed
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<EntityMainClassWhere, EntityMainClassInfo>,
    ));
  }
}

/// @nodoc
abstract class _$EntityMainClassesMapCopyWith<$Res>
    implements $EntityMainClassesMapCopyWith<$Res> {
  factory _$EntityMainClassesMapCopyWith(_EntityMainClassesMap value,
          $Res Function(_EntityMainClassesMap) then) =
      __$EntityMainClassesMapCopyWithImpl<$Res>;
  @override
  $Res call({Map<EntityMainClassWhere, EntityMainClassInfo> map});
}

/// @nodoc
class __$EntityMainClassesMapCopyWithImpl<$Res>
    extends _$EntityMainClassesMapCopyWithImpl<$Res>
    implements _$EntityMainClassesMapCopyWith<$Res> {
  __$EntityMainClassesMapCopyWithImpl(
      _EntityMainClassesMap _value, $Res Function(_EntityMainClassesMap) _then)
      : super(_value, (v) => _then(v as _EntityMainClassesMap));

  @override
  _EntityMainClassesMap get _value => super._value as _EntityMainClassesMap;

  @override
  $Res call({
    Object? map = freezed,
  }) {
    return _then(_EntityMainClassesMap(
      map == freezed
          ? _value.map
          : map // ignore: cast_nullable_to_non_nullable
              as Map<EntityMainClassWhere, EntityMainClassInfo>,
    ));
  }
}

/// @nodoc

class _$_EntityMainClassesMap implements _EntityMainClassesMap {
  _$_EntityMainClassesMap(this.map);

  @override
  final Map<EntityMainClassWhere, EntityMainClassInfo> map;

  @override
  String toString() {
    return 'EntityMainClassesMap(map: $map)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainClassesMap &&
            (identical(other.map, map) ||
                const DeepCollectionEquality().equals(other.map, map)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(map);

  @JsonKey(ignore: true)
  @override
  _$EntityMainClassesMapCopyWith<_EntityMainClassesMap> get copyWith =>
      __$EntityMainClassesMapCopyWithImpl<_EntityMainClassesMap>(
          this, _$identity);
}

abstract class _EntityMainClassesMap implements EntityMainClassesMap {
  factory _EntityMainClassesMap(
          Map<EntityMainClassWhere, EntityMainClassInfo> map) =
      _$_EntityMainClassesMap;

  @override
  Map<EntityMainClassWhere, EntityMainClassInfo> get map =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainClassesMapCopyWith<_EntityMainClassesMap> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainClassesImportTearOff {
  const _$EntityMainClassesImportTearOff();

  _EntityMainClassesImport call(
      EntityMainTermInfo info, EntityMainClassesMap classes) {
    return _EntityMainClassesImport(
      info,
      classes,
    );
  }
}

/// @nodoc
const $EntityMainClassesImport = _$EntityMainClassesImportTearOff();

/// @nodoc
mixin _$EntityMainClassesImport {
  EntityMainTermInfo get info => throw _privateConstructorUsedError;
  EntityMainClassesMap get classes => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainClassesImportCopyWith<EntityMainClassesImport> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainClassesImportCopyWith<$Res> {
  factory $EntityMainClassesImportCopyWith(EntityMainClassesImport value,
          $Res Function(EntityMainClassesImport) then) =
      _$EntityMainClassesImportCopyWithImpl<$Res>;
  $Res call({EntityMainTermInfo info, EntityMainClassesMap classes});

  $EntityMainTermInfoCopyWith<$Res> get info;
  $EntityMainClassesMapCopyWith<$Res> get classes;
}

/// @nodoc
class _$EntityMainClassesImportCopyWithImpl<$Res>
    implements $EntityMainClassesImportCopyWith<$Res> {
  _$EntityMainClassesImportCopyWithImpl(this._value, this._then);

  final EntityMainClassesImport _value;
  // ignore: unused_field
  final $Res Function(EntityMainClassesImport) _then;

  @override
  $Res call({
    Object? info = freezed,
    Object? classes = freezed,
  }) {
    return _then(_value.copyWith(
      info: info == freezed
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as EntityMainTermInfo,
      classes: classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as EntityMainClassesMap,
    ));
  }

  @override
  $EntityMainTermInfoCopyWith<$Res> get info {
    return $EntityMainTermInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }

  @override
  $EntityMainClassesMapCopyWith<$Res> get classes {
    return $EntityMainClassesMapCopyWith<$Res>(_value.classes, (value) {
      return _then(_value.copyWith(classes: value));
    });
  }
}

/// @nodoc
abstract class _$EntityMainClassesImportCopyWith<$Res>
    implements $EntityMainClassesImportCopyWith<$Res> {
  factory _$EntityMainClassesImportCopyWith(_EntityMainClassesImport value,
          $Res Function(_EntityMainClassesImport) then) =
      __$EntityMainClassesImportCopyWithImpl<$Res>;
  @override
  $Res call({EntityMainTermInfo info, EntityMainClassesMap classes});

  @override
  $EntityMainTermInfoCopyWith<$Res> get info;
  @override
  $EntityMainClassesMapCopyWith<$Res> get classes;
}

/// @nodoc
class __$EntityMainClassesImportCopyWithImpl<$Res>
    extends _$EntityMainClassesImportCopyWithImpl<$Res>
    implements _$EntityMainClassesImportCopyWith<$Res> {
  __$EntityMainClassesImportCopyWithImpl(_EntityMainClassesImport _value,
      $Res Function(_EntityMainClassesImport) _then)
      : super(_value, (v) => _then(v as _EntityMainClassesImport));

  @override
  _EntityMainClassesImport get _value =>
      super._value as _EntityMainClassesImport;

  @override
  $Res call({
    Object? info = freezed,
    Object? classes = freezed,
  }) {
    return _then(_EntityMainClassesImport(
      info == freezed
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as EntityMainTermInfo,
      classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as EntityMainClassesMap,
    ));
  }
}

/// @nodoc

class _$_EntityMainClassesImport implements _EntityMainClassesImport {
  _$_EntityMainClassesImport(this.info, this.classes);

  @override
  final EntityMainTermInfo info;
  @override
  final EntityMainClassesMap classes;

  @override
  String toString() {
    return 'EntityMainClassesImport(info: $info, classes: $classes)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainClassesImport &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)) &&
            (identical(other.classes, classes) ||
                const DeepCollectionEquality().equals(other.classes, classes)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(info) ^
      const DeepCollectionEquality().hash(classes);

  @JsonKey(ignore: true)
  @override
  _$EntityMainClassesImportCopyWith<_EntityMainClassesImport> get copyWith =>
      __$EntityMainClassesImportCopyWithImpl<_EntityMainClassesImport>(
          this, _$identity);
}

abstract class _EntityMainClassesImport implements EntityMainClassesImport {
  factory _EntityMainClassesImport(
          EntityMainTermInfo info, EntityMainClassesMap classes) =
      _$_EntityMainClassesImport;

  @override
  EntityMainTermInfo get info => throw _privateConstructorUsedError;
  @override
  EntityMainClassesMap get classes => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainClassesImportCopyWith<_EntityMainClassesImport> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainClassesTearOff {
  const _$EntityMainClassesTearOff();

  _EntityMainClasses call(EntityMainTermKey key, EntityMainTermInfo info,
      EntityMainClassesMap classes, Map<EntityMainClassInfo, double> colors) {
    return _EntityMainClasses(
      key,
      info,
      classes,
      colors,
    );
  }
}

/// @nodoc
const $EntityMainClasses = _$EntityMainClassesTearOff();

/// @nodoc
mixin _$EntityMainClasses {
  EntityMainTermKey get key => throw _privateConstructorUsedError;
  EntityMainTermInfo get info => throw _privateConstructorUsedError;
  EntityMainClassesMap get classes => throw _privateConstructorUsedError;
  Map<EntityMainClassInfo, double> get colors =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainClassesCopyWith<EntityMainClasses> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainClassesCopyWith<$Res> {
  factory $EntityMainClassesCopyWith(
          EntityMainClasses value, $Res Function(EntityMainClasses) then) =
      _$EntityMainClassesCopyWithImpl<$Res>;
  $Res call(
      {EntityMainTermKey key,
      EntityMainTermInfo info,
      EntityMainClassesMap classes,
      Map<EntityMainClassInfo, double> colors});

  $EntityMainTermKeyCopyWith<$Res> get key;
  $EntityMainTermInfoCopyWith<$Res> get info;
  $EntityMainClassesMapCopyWith<$Res> get classes;
}

/// @nodoc
class _$EntityMainClassesCopyWithImpl<$Res>
    implements $EntityMainClassesCopyWith<$Res> {
  _$EntityMainClassesCopyWithImpl(this._value, this._then);

  final EntityMainClasses _value;
  // ignore: unused_field
  final $Res Function(EntityMainClasses) _then;

  @override
  $Res call({
    Object? key = freezed,
    Object? info = freezed,
    Object? classes = freezed,
    Object? colors = freezed,
  }) {
    return _then(_value.copyWith(
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
      info: info == freezed
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as EntityMainTermInfo,
      classes: classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as EntityMainClassesMap,
      colors: colors == freezed
          ? _value.colors
          : colors // ignore: cast_nullable_to_non_nullable
              as Map<EntityMainClassInfo, double>,
    ));
  }

  @override
  $EntityMainTermKeyCopyWith<$Res> get key {
    return $EntityMainTermKeyCopyWith<$Res>(_value.key, (value) {
      return _then(_value.copyWith(key: value));
    });
  }

  @override
  $EntityMainTermInfoCopyWith<$Res> get info {
    return $EntityMainTermInfoCopyWith<$Res>(_value.info, (value) {
      return _then(_value.copyWith(info: value));
    });
  }

  @override
  $EntityMainClassesMapCopyWith<$Res> get classes {
    return $EntityMainClassesMapCopyWith<$Res>(_value.classes, (value) {
      return _then(_value.copyWith(classes: value));
    });
  }
}

/// @nodoc
abstract class _$EntityMainClassesCopyWith<$Res>
    implements $EntityMainClassesCopyWith<$Res> {
  factory _$EntityMainClassesCopyWith(
          _EntityMainClasses value, $Res Function(_EntityMainClasses) then) =
      __$EntityMainClassesCopyWithImpl<$Res>;
  @override
  $Res call(
      {EntityMainTermKey key,
      EntityMainTermInfo info,
      EntityMainClassesMap classes,
      Map<EntityMainClassInfo, double> colors});

  @override
  $EntityMainTermKeyCopyWith<$Res> get key;
  @override
  $EntityMainTermInfoCopyWith<$Res> get info;
  @override
  $EntityMainClassesMapCopyWith<$Res> get classes;
}

/// @nodoc
class __$EntityMainClassesCopyWithImpl<$Res>
    extends _$EntityMainClassesCopyWithImpl<$Res>
    implements _$EntityMainClassesCopyWith<$Res> {
  __$EntityMainClassesCopyWithImpl(
      _EntityMainClasses _value, $Res Function(_EntityMainClasses) _then)
      : super(_value, (v) => _then(v as _EntityMainClasses));

  @override
  _EntityMainClasses get _value => super._value as _EntityMainClasses;

  @override
  $Res call({
    Object? key = freezed,
    Object? info = freezed,
    Object? classes = freezed,
    Object? colors = freezed,
  }) {
    return _then(_EntityMainClasses(
      key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
      info == freezed
          ? _value.info
          : info // ignore: cast_nullable_to_non_nullable
              as EntityMainTermInfo,
      classes == freezed
          ? _value.classes
          : classes // ignore: cast_nullable_to_non_nullable
              as EntityMainClassesMap,
      colors == freezed
          ? _value.colors
          : colors // ignore: cast_nullable_to_non_nullable
              as Map<EntityMainClassInfo, double>,
    ));
  }
}

/// @nodoc

class _$_EntityMainClasses implements _EntityMainClasses {
  _$_EntityMainClasses(this.key, this.info, this.classes, this.colors);

  @override
  final EntityMainTermKey key;
  @override
  final EntityMainTermInfo info;
  @override
  final EntityMainClassesMap classes;
  @override
  final Map<EntityMainClassInfo, double> colors;

  @override
  String toString() {
    return 'EntityMainClasses(key: $key, info: $info, classes: $classes, colors: $colors)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainClasses &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.info, info) ||
                const DeepCollectionEquality().equals(other.info, info)) &&
            (identical(other.classes, classes) ||
                const DeepCollectionEquality()
                    .equals(other.classes, classes)) &&
            (identical(other.colors, colors) ||
                const DeepCollectionEquality().equals(other.colors, colors)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(info) ^
      const DeepCollectionEquality().hash(classes) ^
      const DeepCollectionEquality().hash(colors);

  @JsonKey(ignore: true)
  @override
  _$EntityMainClassesCopyWith<_EntityMainClasses> get copyWith =>
      __$EntityMainClassesCopyWithImpl<_EntityMainClasses>(this, _$identity);
}

abstract class _EntityMainClasses implements EntityMainClasses {
  factory _EntityMainClasses(
      EntityMainTermKey key,
      EntityMainTermInfo info,
      EntityMainClassesMap classes,
      Map<EntityMainClassInfo, double> colors) = _$_EntityMainClasses;

  @override
  EntityMainTermKey get key => throw _privateConstructorUsedError;
  @override
  EntityMainTermInfo get info => throw _privateConstructorUsedError;
  @override
  EntityMainClassesMap get classes => throw _privateConstructorUsedError;
  @override
  Map<EntityMainClassInfo, double> get colors =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainClassesCopyWith<_EntityMainClasses> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainTermInfoTearOff {
  const _$EntityMainTermInfoTearOff();

  _EntityMainTermInfo call(
      String name, Set<Duration> periods, Set<WeekDay> weekDays) {
    return _EntityMainTermInfo(
      name,
      periods,
      weekDays,
    );
  }
}

/// @nodoc
const $EntityMainTermInfo = _$EntityMainTermInfoTearOff();

/// @nodoc
mixin _$EntityMainTermInfo {
  String get name => throw _privateConstructorUsedError;
  Set<Duration> get periods => throw _privateConstructorUsedError;
  Set<WeekDay> get weekDays => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainTermInfoCopyWith<EntityMainTermInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainTermInfoCopyWith<$Res> {
  factory $EntityMainTermInfoCopyWith(
          EntityMainTermInfo value, $Res Function(EntityMainTermInfo) then) =
      _$EntityMainTermInfoCopyWithImpl<$Res>;
  $Res call({String name, Set<Duration> periods, Set<WeekDay> weekDays});
}

/// @nodoc
class _$EntityMainTermInfoCopyWithImpl<$Res>
    implements $EntityMainTermInfoCopyWith<$Res> {
  _$EntityMainTermInfoCopyWithImpl(this._value, this._then);

  final EntityMainTermInfo _value;
  // ignore: unused_field
  final $Res Function(EntityMainTermInfo) _then;

  @override
  $Res call({
    Object? name = freezed,
    Object? periods = freezed,
    Object? weekDays = freezed,
  }) {
    return _then(_value.copyWith(
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      periods: periods == freezed
          ? _value.periods
          : periods // ignore: cast_nullable_to_non_nullable
              as Set<Duration>,
      weekDays: weekDays == freezed
          ? _value.weekDays
          : weekDays // ignore: cast_nullable_to_non_nullable
              as Set<WeekDay>,
    ));
  }
}

/// @nodoc
abstract class _$EntityMainTermInfoCopyWith<$Res>
    implements $EntityMainTermInfoCopyWith<$Res> {
  factory _$EntityMainTermInfoCopyWith(
          _EntityMainTermInfo value, $Res Function(_EntityMainTermInfo) then) =
      __$EntityMainTermInfoCopyWithImpl<$Res>;
  @override
  $Res call({String name, Set<Duration> periods, Set<WeekDay> weekDays});
}

/// @nodoc
class __$EntityMainTermInfoCopyWithImpl<$Res>
    extends _$EntityMainTermInfoCopyWithImpl<$Res>
    implements _$EntityMainTermInfoCopyWith<$Res> {
  __$EntityMainTermInfoCopyWithImpl(
      _EntityMainTermInfo _value, $Res Function(_EntityMainTermInfo) _then)
      : super(_value, (v) => _then(v as _EntityMainTermInfo));

  @override
  _EntityMainTermInfo get _value => super._value as _EntityMainTermInfo;

  @override
  $Res call({
    Object? name = freezed,
    Object? periods = freezed,
    Object? weekDays = freezed,
  }) {
    return _then(_EntityMainTermInfo(
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      periods == freezed
          ? _value.periods
          : periods // ignore: cast_nullable_to_non_nullable
              as Set<Duration>,
      weekDays == freezed
          ? _value.weekDays
          : weekDays // ignore: cast_nullable_to_non_nullable
              as Set<WeekDay>,
    ));
  }
}

/// @nodoc

class _$_EntityMainTermInfo implements _EntityMainTermInfo {
  _$_EntityMainTermInfo(this.name, this.periods, this.weekDays);

  @override
  final String name;
  @override
  final Set<Duration> periods;
  @override
  final Set<WeekDay> weekDays;

  @override
  String toString() {
    return 'EntityMainTermInfo(name: $name, periods: $periods, weekDays: $weekDays)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainTermInfo &&
            (identical(other.name, name) ||
                const DeepCollectionEquality().equals(other.name, name)) &&
            (identical(other.periods, periods) ||
                const DeepCollectionEquality()
                    .equals(other.periods, periods)) &&
            (identical(other.weekDays, weekDays) ||
                const DeepCollectionEquality()
                    .equals(other.weekDays, weekDays)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(name) ^
      const DeepCollectionEquality().hash(periods) ^
      const DeepCollectionEquality().hash(weekDays);

  @JsonKey(ignore: true)
  @override
  _$EntityMainTermInfoCopyWith<_EntityMainTermInfo> get copyWith =>
      __$EntityMainTermInfoCopyWithImpl<_EntityMainTermInfo>(this, _$identity);
}

abstract class _EntityMainTermInfo implements EntityMainTermInfo {
  factory _EntityMainTermInfo(
          String name, Set<Duration> periods, Set<WeekDay> weekDays) =
      _$_EntityMainTermInfo;

  @override
  String get name => throw _privateConstructorUsedError;
  @override
  Set<Duration> get periods => throw _privateConstructorUsedError;
  @override
  Set<WeekDay> get weekDays => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainTermInfoCopyWith<_EntityMainTermInfo> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainTermKeyTearOff {
  const _$EntityMainTermKeyTearOff();

  _EntityMainTermKey call(int id) {
    return _EntityMainTermKey(
      id,
    );
  }
}

/// @nodoc
const $EntityMainTermKey = _$EntityMainTermKeyTearOff();

/// @nodoc
mixin _$EntityMainTermKey {
  int get id => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainTermKeyCopyWith<EntityMainTermKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainTermKeyCopyWith<$Res> {
  factory $EntityMainTermKeyCopyWith(
          EntityMainTermKey value, $Res Function(EntityMainTermKey) then) =
      _$EntityMainTermKeyCopyWithImpl<$Res>;
  $Res call({int id});
}

/// @nodoc
class _$EntityMainTermKeyCopyWithImpl<$Res>
    implements $EntityMainTermKeyCopyWith<$Res> {
  _$EntityMainTermKeyCopyWithImpl(this._value, this._then);

  final EntityMainTermKey _value;
  // ignore: unused_field
  final $Res Function(EntityMainTermKey) _then;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_value.copyWith(
      id: id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$EntityMainTermKeyCopyWith<$Res>
    implements $EntityMainTermKeyCopyWith<$Res> {
  factory _$EntityMainTermKeyCopyWith(
          _EntityMainTermKey value, $Res Function(_EntityMainTermKey) then) =
      __$EntityMainTermKeyCopyWithImpl<$Res>;
  @override
  $Res call({int id});
}

/// @nodoc
class __$EntityMainTermKeyCopyWithImpl<$Res>
    extends _$EntityMainTermKeyCopyWithImpl<$Res>
    implements _$EntityMainTermKeyCopyWith<$Res> {
  __$EntityMainTermKeyCopyWithImpl(
      _EntityMainTermKey _value, $Res Function(_EntityMainTermKey) _then)
      : super(_value, (v) => _then(v as _EntityMainTermKey));

  @override
  _EntityMainTermKey get _value => super._value as _EntityMainTermKey;

  @override
  $Res call({
    Object? id = freezed,
  }) {
    return _then(_EntityMainTermKey(
      id == freezed
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_EntityMainTermKey implements _EntityMainTermKey {
  _$_EntityMainTermKey(this.id);

  @override
  final int id;

  @override
  String toString() {
    return 'EntityMainTermKey(id: $id)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainTermKey &&
            (identical(other.id, id) ||
                const DeepCollectionEquality().equals(other.id, id)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(id);

  @JsonKey(ignore: true)
  @override
  _$EntityMainTermKeyCopyWith<_EntityMainTermKey> get copyWith =>
      __$EntityMainTermKeyCopyWithImpl<_EntityMainTermKey>(this, _$identity);
}

abstract class _EntityMainTermKey implements EntityMainTermKey {
  factory _EntityMainTermKey(int id) = _$_EntityMainTermKey;

  @override
  int get id => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainTermKeyCopyWith<_EntityMainTermKey> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainTermTearOff {
  const _$EntityMainTermTearOff();

  _EntityMainTerm call(EntityMainTermKey key, EntityMainTermInfo value) {
    return _EntityMainTerm(
      key,
      value,
    );
  }
}

/// @nodoc
const $EntityMainTerm = _$EntityMainTermTearOff();

/// @nodoc
mixin _$EntityMainTerm {
  EntityMainTermKey get key => throw _privateConstructorUsedError;
  EntityMainTermInfo get value => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainTermCopyWith<EntityMainTerm> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainTermCopyWith<$Res> {
  factory $EntityMainTermCopyWith(
          EntityMainTerm value, $Res Function(EntityMainTerm) then) =
      _$EntityMainTermCopyWithImpl<$Res>;
  $Res call({EntityMainTermKey key, EntityMainTermInfo value});

  $EntityMainTermKeyCopyWith<$Res> get key;
  $EntityMainTermInfoCopyWith<$Res> get value;
}

/// @nodoc
class _$EntityMainTermCopyWithImpl<$Res>
    implements $EntityMainTermCopyWith<$Res> {
  _$EntityMainTermCopyWithImpl(this._value, this._then);

  final EntityMainTerm _value;
  // ignore: unused_field
  final $Res Function(EntityMainTerm) _then;

  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
  }) {
    return _then(_value.copyWith(
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
      value: value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as EntityMainTermInfo,
    ));
  }

  @override
  $EntityMainTermKeyCopyWith<$Res> get key {
    return $EntityMainTermKeyCopyWith<$Res>(_value.key, (value) {
      return _then(_value.copyWith(key: value));
    });
  }

  @override
  $EntityMainTermInfoCopyWith<$Res> get value {
    return $EntityMainTermInfoCopyWith<$Res>(_value.value, (value) {
      return _then(_value.copyWith(value: value));
    });
  }
}

/// @nodoc
abstract class _$EntityMainTermCopyWith<$Res>
    implements $EntityMainTermCopyWith<$Res> {
  factory _$EntityMainTermCopyWith(
          _EntityMainTerm value, $Res Function(_EntityMainTerm) then) =
      __$EntityMainTermCopyWithImpl<$Res>;
  @override
  $Res call({EntityMainTermKey key, EntityMainTermInfo value});

  @override
  $EntityMainTermKeyCopyWith<$Res> get key;
  @override
  $EntityMainTermInfoCopyWith<$Res> get value;
}

/// @nodoc
class __$EntityMainTermCopyWithImpl<$Res>
    extends _$EntityMainTermCopyWithImpl<$Res>
    implements _$EntityMainTermCopyWith<$Res> {
  __$EntityMainTermCopyWithImpl(
      _EntityMainTerm _value, $Res Function(_EntityMainTerm) _then)
      : super(_value, (v) => _then(v as _EntityMainTerm));

  @override
  _EntityMainTerm get _value => super._value as _EntityMainTerm;

  @override
  $Res call({
    Object? key = freezed,
    Object? value = freezed,
  }) {
    return _then(_EntityMainTerm(
      key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as EntityMainTermInfo,
    ));
  }
}

/// @nodoc

class _$_EntityMainTerm implements _EntityMainTerm {
  _$_EntityMainTerm(this.key, this.value);

  @override
  final EntityMainTermKey key;
  @override
  final EntityMainTermInfo value;

  @override
  String toString() {
    return 'EntityMainTerm(key: $key, value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainTerm &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  _$EntityMainTermCopyWith<_EntityMainTerm> get copyWith =>
      __$EntityMainTermCopyWithImpl<_EntityMainTerm>(this, _$identity);
}

abstract class _EntityMainTerm implements EntityMainTerm {
  factory _EntityMainTerm(EntityMainTermKey key, EntityMainTermInfo value) =
      _$_EntityMainTerm;

  @override
  EntityMainTermKey get key => throw _privateConstructorUsedError;
  @override
  EntityMainTermInfo get value => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainTermCopyWith<_EntityMainTerm> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainTermsTearOff {
  const _$EntityMainTermsTearOff();

  _EntityMainTerms call(Map<EntityMainTermKey, EntityMainTermInfo> terms,
      EntityMainTermKey currentTerm) {
    return _EntityMainTerms(
      terms,
      currentTerm,
    );
  }
}

/// @nodoc
const $EntityMainTerms = _$EntityMainTermsTearOff();

/// @nodoc
mixin _$EntityMainTerms {
  Map<EntityMainTermKey, EntityMainTermInfo> get terms =>
      throw _privateConstructorUsedError;
  EntityMainTermKey get currentTerm => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainTermsCopyWith<EntityMainTerms> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainTermsCopyWith<$Res> {
  factory $EntityMainTermsCopyWith(
          EntityMainTerms value, $Res Function(EntityMainTerms) then) =
      _$EntityMainTermsCopyWithImpl<$Res>;
  $Res call(
      {Map<EntityMainTermKey, EntityMainTermInfo> terms,
      EntityMainTermKey currentTerm});

  $EntityMainTermKeyCopyWith<$Res> get currentTerm;
}

/// @nodoc
class _$EntityMainTermsCopyWithImpl<$Res>
    implements $EntityMainTermsCopyWith<$Res> {
  _$EntityMainTermsCopyWithImpl(this._value, this._then);

  final EntityMainTerms _value;
  // ignore: unused_field
  final $Res Function(EntityMainTerms) _then;

  @override
  $Res call({
    Object? terms = freezed,
    Object? currentTerm = freezed,
  }) {
    return _then(_value.copyWith(
      terms: terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as Map<EntityMainTermKey, EntityMainTermInfo>,
      currentTerm: currentTerm == freezed
          ? _value.currentTerm
          : currentTerm // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
    ));
  }

  @override
  $EntityMainTermKeyCopyWith<$Res> get currentTerm {
    return $EntityMainTermKeyCopyWith<$Res>(_value.currentTerm, (value) {
      return _then(_value.copyWith(currentTerm: value));
    });
  }
}

/// @nodoc
abstract class _$EntityMainTermsCopyWith<$Res>
    implements $EntityMainTermsCopyWith<$Res> {
  factory _$EntityMainTermsCopyWith(
          _EntityMainTerms value, $Res Function(_EntityMainTerms) then) =
      __$EntityMainTermsCopyWithImpl<$Res>;
  @override
  $Res call(
      {Map<EntityMainTermKey, EntityMainTermInfo> terms,
      EntityMainTermKey currentTerm});

  @override
  $EntityMainTermKeyCopyWith<$Res> get currentTerm;
}

/// @nodoc
class __$EntityMainTermsCopyWithImpl<$Res>
    extends _$EntityMainTermsCopyWithImpl<$Res>
    implements _$EntityMainTermsCopyWith<$Res> {
  __$EntityMainTermsCopyWithImpl(
      _EntityMainTerms _value, $Res Function(_EntityMainTerms) _then)
      : super(_value, (v) => _then(v as _EntityMainTerms));

  @override
  _EntityMainTerms get _value => super._value as _EntityMainTerms;

  @override
  $Res call({
    Object? terms = freezed,
    Object? currentTerm = freezed,
  }) {
    return _then(_EntityMainTerms(
      terms == freezed
          ? _value.terms
          : terms // ignore: cast_nullable_to_non_nullable
              as Map<EntityMainTermKey, EntityMainTermInfo>,
      currentTerm == freezed
          ? _value.currentTerm
          : currentTerm // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
    ));
  }
}

/// @nodoc

class _$_EntityMainTerms implements _EntityMainTerms {
  _$_EntityMainTerms(this.terms, this.currentTerm);

  @override
  final Map<EntityMainTermKey, EntityMainTermInfo> terms;
  @override
  final EntityMainTermKey currentTerm;

  @override
  String toString() {
    return 'EntityMainTerms(terms: $terms, currentTerm: $currentTerm)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainTerms &&
            (identical(other.terms, terms) ||
                const DeepCollectionEquality().equals(other.terms, terms)) &&
            (identical(other.currentTerm, currentTerm) ||
                const DeepCollectionEquality()
                    .equals(other.currentTerm, currentTerm)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(terms) ^
      const DeepCollectionEquality().hash(currentTerm);

  @JsonKey(ignore: true)
  @override
  _$EntityMainTermsCopyWith<_EntityMainTerms> get copyWith =>
      __$EntityMainTermsCopyWithImpl<_EntityMainTerms>(this, _$identity);
}

abstract class _EntityMainTerms implements EntityMainTerms {
  factory _EntityMainTerms(Map<EntityMainTermKey, EntityMainTermInfo> terms,
      EntityMainTermKey currentTerm) = _$_EntityMainTerms;

  @override
  Map<EntityMainTermKey, EntityMainTermInfo> get terms =>
      throw _privateConstructorUsedError;
  @override
  EntityMainTermKey get currentTerm => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainTermsCopyWith<_EntityMainTerms> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$EntityMainTermEditingTearOff {
  const _$EntityMainTermEditingTearOff();

  _EntityMainTermEditing call(EntityMainTermKey key, String? initialName,
      Set<Duration> periods, Set<WeekDay> weekDays) {
    return _EntityMainTermEditing(
      key,
      initialName,
      periods,
      weekDays,
    );
  }
}

/// @nodoc
const $EntityMainTermEditing = _$EntityMainTermEditingTearOff();

/// @nodoc
mixin _$EntityMainTermEditing {
  EntityMainTermKey get key => throw _privateConstructorUsedError;
  String? get initialName => throw _privateConstructorUsedError;
  Set<Duration> get periods => throw _privateConstructorUsedError;
  Set<WeekDay> get weekDays => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $EntityMainTermEditingCopyWith<EntityMainTermEditing> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EntityMainTermEditingCopyWith<$Res> {
  factory $EntityMainTermEditingCopyWith(EntityMainTermEditing value,
          $Res Function(EntityMainTermEditing) then) =
      _$EntityMainTermEditingCopyWithImpl<$Res>;
  $Res call(
      {EntityMainTermKey key,
      String? initialName,
      Set<Duration> periods,
      Set<WeekDay> weekDays});

  $EntityMainTermKeyCopyWith<$Res> get key;
}

/// @nodoc
class _$EntityMainTermEditingCopyWithImpl<$Res>
    implements $EntityMainTermEditingCopyWith<$Res> {
  _$EntityMainTermEditingCopyWithImpl(this._value, this._then);

  final EntityMainTermEditing _value;
  // ignore: unused_field
  final $Res Function(EntityMainTermEditing) _then;

  @override
  $Res call({
    Object? key = freezed,
    Object? initialName = freezed,
    Object? periods = freezed,
    Object? weekDays = freezed,
  }) {
    return _then(_value.copyWith(
      key: key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
      initialName: initialName == freezed
          ? _value.initialName
          : initialName // ignore: cast_nullable_to_non_nullable
              as String?,
      periods: periods == freezed
          ? _value.periods
          : periods // ignore: cast_nullable_to_non_nullable
              as Set<Duration>,
      weekDays: weekDays == freezed
          ? _value.weekDays
          : weekDays // ignore: cast_nullable_to_non_nullable
              as Set<WeekDay>,
    ));
  }

  @override
  $EntityMainTermKeyCopyWith<$Res> get key {
    return $EntityMainTermKeyCopyWith<$Res>(_value.key, (value) {
      return _then(_value.copyWith(key: value));
    });
  }
}

/// @nodoc
abstract class _$EntityMainTermEditingCopyWith<$Res>
    implements $EntityMainTermEditingCopyWith<$Res> {
  factory _$EntityMainTermEditingCopyWith(_EntityMainTermEditing value,
          $Res Function(_EntityMainTermEditing) then) =
      __$EntityMainTermEditingCopyWithImpl<$Res>;
  @override
  $Res call(
      {EntityMainTermKey key,
      String? initialName,
      Set<Duration> periods,
      Set<WeekDay> weekDays});

  @override
  $EntityMainTermKeyCopyWith<$Res> get key;
}

/// @nodoc
class __$EntityMainTermEditingCopyWithImpl<$Res>
    extends _$EntityMainTermEditingCopyWithImpl<$Res>
    implements _$EntityMainTermEditingCopyWith<$Res> {
  __$EntityMainTermEditingCopyWithImpl(_EntityMainTermEditing _value,
      $Res Function(_EntityMainTermEditing) _then)
      : super(_value, (v) => _then(v as _EntityMainTermEditing));

  @override
  _EntityMainTermEditing get _value => super._value as _EntityMainTermEditing;

  @override
  $Res call({
    Object? key = freezed,
    Object? initialName = freezed,
    Object? periods = freezed,
    Object? weekDays = freezed,
  }) {
    return _then(_EntityMainTermEditing(
      key == freezed
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as EntityMainTermKey,
      initialName == freezed
          ? _value.initialName
          : initialName // ignore: cast_nullable_to_non_nullable
              as String?,
      periods == freezed
          ? _value.periods
          : periods // ignore: cast_nullable_to_non_nullable
              as Set<Duration>,
      weekDays == freezed
          ? _value.weekDays
          : weekDays // ignore: cast_nullable_to_non_nullable
              as Set<WeekDay>,
    ));
  }
}

/// @nodoc

class _$_EntityMainTermEditing implements _EntityMainTermEditing {
  _$_EntityMainTermEditing(
      this.key, this.initialName, this.periods, this.weekDays);

  @override
  final EntityMainTermKey key;
  @override
  final String? initialName;
  @override
  final Set<Duration> periods;
  @override
  final Set<WeekDay> weekDays;

  @override
  String toString() {
    return 'EntityMainTermEditing(key: $key, initialName: $initialName, periods: $periods, weekDays: $weekDays)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _EntityMainTermEditing &&
            (identical(other.key, key) ||
                const DeepCollectionEquality().equals(other.key, key)) &&
            (identical(other.initialName, initialName) ||
                const DeepCollectionEquality()
                    .equals(other.initialName, initialName)) &&
            (identical(other.periods, periods) ||
                const DeepCollectionEquality()
                    .equals(other.periods, periods)) &&
            (identical(other.weekDays, weekDays) ||
                const DeepCollectionEquality()
                    .equals(other.weekDays, weekDays)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(key) ^
      const DeepCollectionEquality().hash(initialName) ^
      const DeepCollectionEquality().hash(periods) ^
      const DeepCollectionEquality().hash(weekDays);

  @JsonKey(ignore: true)
  @override
  _$EntityMainTermEditingCopyWith<_EntityMainTermEditing> get copyWith =>
      __$EntityMainTermEditingCopyWithImpl<_EntityMainTermEditing>(
          this, _$identity);
}

abstract class _EntityMainTermEditing implements EntityMainTermEditing {
  factory _EntityMainTermEditing(EntityMainTermKey key, String? initialName,
      Set<Duration> periods, Set<WeekDay> weekDays) = _$_EntityMainTermEditing;

  @override
  EntityMainTermKey get key => throw _privateConstructorUsedError;
  @override
  String? get initialName => throw _privateConstructorUsedError;
  @override
  Set<Duration> get periods => throw _privateConstructorUsedError;
  @override
  Set<WeekDay> get weekDays => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$EntityMainTermEditingCopyWith<_EntityMainTermEditing> get copyWith =>
      throw _privateConstructorUsedError;
}
